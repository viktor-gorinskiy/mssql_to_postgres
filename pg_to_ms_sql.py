import config
import ms_sql
import pg_sql



class MStoPGsql():
   
    def return_type(self, type_data, len_data, scale):                  # Возвращает типы данных
        if type_data == 'int': return 'INT'
        if type_data == 'int identity': return 'INT GENERATED BY default AS IDENTITY'
        if type_data == 'smallint': return 'SMALLINT'
        if type_data == 'nchar': return f'CHAR({len_data})'
        if type_data == 'nvarchar': return f'VARCHAR({len_data})'
        if type_data == 'decimal': return f'DECIMAL({len_data}, {scale})'
        if type_data == 'float': return 'DOUBLE PRECISION'
        if type_data == 'tinyint': return 'SMALLINT'
        if type_data == 'bit': return 'BOOLEAN'
        if type_data == 'datetime': return 'TIMESTAMP'
        if type_data == 'smalldatetime': return 'TIMESTAMP'
        if type_data == 'date': return 'DATE'
        # if type_data == 'uniqueidentifier': return 'CHAR(16)'
        if type_data == 'uniqueidentifier': return 'UUID'
        if type_data == 'ntext': return 'TEXT'
        if type_data == 'bigint identity': return 'BIGINT'
        if type_data == 'image': return 'BYTEA'
        if type_data == 'varbinary': return 'BYTEA'
        return type_data    # Возвращаем то, что пришло, если ничего не подошло.

    def return_null(self, is_nul):                                      # Если Not Null 'YES', то заменяем на 'NULL' иначе 'NOT NULL'
        if is_nul == 'YES': return 'NULL'
        return 'NOT NULL'
    
    def get_MStoPG_columns(self, schema, table):                                # Возвращает поля с типом данных для Postgres
        columns = mssql.get_columns(schema=schema, table=table)
        sql_lines = []
        for column in columns:
            type_d = self.return_type(column[5], column[6], column[8])  # преобразуем тип данных ==> type_data, len_data, scale
            is_null = self.return_null(column[17])                      # Если Not Null 'YES', то заменяем на 'NULL' иначе 'NOT NULL'
            sql_line = f""""{column[3]}" {type_d} {is_null}"""          # Формируем строку для создания поля
            sql_lines.append(sql_line)
        return sql_lines

    def get_sql_create_table_to_pg(self, schema, table):                # Возвращает строку с правильным SQL для создания таблицы в PG   
        sql = f"""CREATE TABLE IF NOT EXISTS {schema}.{table}(\n"""
        c = 0
        sql_lenes = self.get_MStoPG_columns(schema, table)
        for sql_lene in sql_lenes:
            c+=1
            sql += sql_lene
            if c < len(sql_lenes):
                sql += ',\n'
        pk_str = mssql.get_primaryKeys(table=table, schema=schema)                           # Запрашиваем PrimaryKeys
        if pk_str:
            sql += ',\n' + pk_str + '\n'
        sql += ');'
        return(sql)
    
    def transfer_table(self, schema, table):
        sql = self.get_sql_create_table_to_pg(schema, table)
        pgsql.create_table_manual(sql)

    def gen_S(self, table):
        count_columns = mssql.len_columns(schema, table)
        s_values = (", ".join(['%s' for x in range(count_columns)]))
        return s_values

    def get_schemas(self):
        schemas = []
        for schema in mssql.get_schemas():
            if schema not in config.ignore_schemas:
                schemas.append(schema)
        return schemas
 
mssql = ms_sql.MsSql(
    odbc_driver=config.odbc_driver,
    server=config.ms_server,
    port=config.ms_server_port,
    database=config.ms_database,
    username=config.ms_username,
    password=config.ms_password,
)

pgsql = pg_sql.PgSql(
    server=config.pg_server,
    port=config.pg_server_port,
    database=config.pg_database,
    username=config.pg_username,
    password=config.pg_password
)


mssql.connect()
pgsql.connect()

transfer = MStoPGsql()


# print(transfer.get_schemas())
for schema in transfer.get_schemas():

    pgsql.create_schema(schema)

    tables = mssql.get_tables(schema, ignore_tables=config.ignore_tables, ignore_prefix=config.ignore_prefix)   # Получаем все таблицы

    for table in tables:
        print(schema, table)
        
        if config.drop_tables:                                              # Будем удалять таблицы перед их созданием?
            pgsql.drop_table(schema, table)
            
        transfer.transfer_table(schema, table)                              # Создаем таблицу в Postgress
        
        s_values = transfer.gen_S(table)                                    # Для правильного SQL запроса нужно создать  нужное количество '%s'.
        
        count_records_table = mssql.len_records_in_table(schema, table)     # Получаем общее количество записей в таблице
        all_records_in_table = mssql.get_all_records(schema, table)         # Получаем все записи в таблице
        
        sql_s = []                          # Массив для передачи записей в  Postgress
        cicle = 0                           # Счетчик циклов
        pull = config.pull                  # Количество записей, которые будут добавлены в массив sql_s
        for row in all_records_in_table:    # Перебираем записи по одной
            cicle += 1
            sql_s.append(row)
            
            if not cicle%pull:              # Если заполнился пул, то скидываем его на загрузку в посгрес
                print('\tPull', schema, table, 'cicle ==>', cicle, 'count_records_table ==>', count_records_table, 'len sql_s ==>', len(sql_s))
                pgsql.insert_manyal(table=table, schema=schema, s_values=s_values, list_records=sql_s)        # Само скидывание, скидываем массив 'sql_s'
                sql_s = []
        # А теперь остаток от общего количества записей, кторый не вошел в последний пул
        print('\tEnd', schema, table, 'count_records_table ==>', count_records_table, 'len sql_s ==>', len(sql_s))
        pgsql.insert_manyal(table=table, schema=schema, s_values=s_values, list_records=sql_s)   # Само скидывание
        print()

# Закрываем подключения к базам
mssql.close
pgsql.close
 